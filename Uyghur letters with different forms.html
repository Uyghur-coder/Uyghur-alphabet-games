<!doctype html>
<html lang="en" dir="rtl">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Uyghur Alphabet Click & Match</title>
<script src="https://cdn.tailwindcss.com"></script>
<style>
  body { -webkit-font-smoothing:antialiased; -moz-osx-font-smoothing:grayscale; }
  .card { background: white; border-radius: 1rem; padding: 1rem; box-shadow: 0 6px 18px rgba(15,23,42,0.06); }
  .slot { min-height: 4.5rem; cursor: pointer; }
  button:focus { outline: none; box-shadow: 0 0 0 3px rgba(59,130,246,0.15); }
  .selected { border: 2px solid #3b82f6; }
</style>
</head>
<body class="bg-gray-50 p-6">
<div id="root" class="max-w-6xl mx-auto"></div>

<script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
<script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
<script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

<script type="text/babel">
const { useState, useMemo, useEffect } = React;

const LETTERS = [
{ id:"alef", name:"Ø¦Ø§", label:"a", forms:{final:"Ù€Ø§ØŒ Ù€Ø¦Ø§", isolated:"Ø¦Ø§ØŒ Ø§"} },
{ id:"e1", name:"Ø¦Û•", label:"e", forms:{final:"Ù€Û•ØŒ Ù€Ø¦Û•", isolated:"Ø¦Û•ØŒ Û•"} },
{ id:"beh", name:"Ø¨", label:"b", forms:{final:"Ù€Ø¨", medial:"Ù€Ø¨Ù€", initial:"Ø¨Ù€", isolated:"Ø¨"} },
{ id:"peh", name:"Ù¾", label:"p", forms:{final:"Ù€Ù¾", medial:"Ù€Ù¾Ù€", initial:"Ù¾Ù€", isolated:"Ù¾"} },
{ id:"teh", name:"Øª", label:"t", forms:{final:"Ù€Øª", medial:"Ù€ØªÙ€", initial:"ØªÙ€", isolated:"Øª"} },
{ id:"jeem", name:"Ø¬", label:"j", forms:{final:"Ù€Ø¬", medial:"Ù€Ø¬Ù€", initial:"Ø¬Ù€", isolated:"Ø¬"} },
{ id:"tcheh", name:"Ú†", label:"ch", forms:{final:"Ù€Ú†", medial:"Ù€Ú†Ù€", initial:"Ú†Ù€", isolated:"Ú†"} },
{ id:"kheh", name:"Ø®", label:"kh", forms:{final:"Ù€Ø®", medial:"Ù€Ø®Ù€", initial:"Ø®Ù€", isolated:"Ø®"} },
{ id:"dal", name:"Ø¯", label:"d", forms:{final:"Ù€Ø¯", isolated:"Ø¯"} },
{ id:"reh", name:"Ø±", label:"r", forms:{final:"Ù€Ø±", isolated:"Ø±"} },
{ id:"zain", name:"Ø²", label:"z", forms:{final:"Ù€Ø²", isolated:"Ø²"} },
{ id:"zh", name:"Ú˜", label:"zh", forms:{final:"Ù€Ú˜", isolated:"Ú˜"} },
{ id:"seen", name:"Ø³", label:"s", forms:{final:"Ù€Ø³", medial:"Ù€Ø³Ù€", initial:"Ø³Ù€", isolated:"Ø³"} },
{ id:"sheen", name:"Ø´", label:"sh", forms:{final:"Ù€Ø´", medial:"Ù€Ø´Ù€", initial:"Ø´Ù€", isolated:"Ø´"} },
{ id:"gh", name:"Øº", label:"gh", forms:{final:"Ù€Øº", medial:"Ù€ØºÙ€", initial:"ØºÙ€", isolated:"Øº"} },
{ id:"feh", name:"Ù", label:"f", forms:{final:"Ù€Ù", medial:"Ù€ÙÙ€", initial:"ÙÙ€", isolated:"Ù"} },
{ id:"qaf", name:"Ù‚", label:"q", forms:{final:"Ù€Ù‚", medial:"Ù€Ù‚Ù€", initial:"Ù‚Ù€", isolated:"Ù‚"} },
{ id:"kaf", name:"Ùƒ", label:"k", forms:{final:"Ù€Ùƒ", medial:"Ù€ÙƒÙ€", initial:"ÙƒÙ€", isolated:"Ùƒ"} },
{ id:"gaf", name:"Ú¯", label:"g", forms:{final:"Ù€Ú¯", medial:"Ù€Ú¯Ù€", initial:"Ú¯Ù€", isolated:"Ú¯"} },
{ id:"ng", name:"Ú­", label:"ng", forms:{final:"Ù€Ú­", medial:"Ù€Ú­Ù€", initial:"Ú­Ù€", isolated:"Ú­"} },
{ id:"lam", name:"Ù„", label:"l", forms:{final:"Ù€Ù„", medial:"Ù€Ù„Ù€", initial:"Ù„Ù€", isolated:"Ù„"} },
{ id:"meem", name:"Ù…", label:"m", forms:{final:"Ù€Ù…", medial:"Ù€Ù…Ù€", initial:"Ù…Ù€", isolated:"Ù…"} },
{ id:"noon", name:"Ù†", label:"n", forms:{final:"Ù€Ù†", medial:"Ù€Ù†Ù€", initial:"Ù†Ù€", isolated:"Ù†"} },
{ id:"heh", name:"Ú¾", label:"h", forms:{final:"Ù€Ú¾", medial:"Ù€Ú¾Ù€", initial:"Ú¾Ù€", isolated:"Ú¾"} },
{ id:"o", name:"Ø¦Ùˆ", label:"o", forms:{final:"Ù€ÙˆØŒ Ù€Ø¦Ùˆ", isolated:"Ø¦ÙˆØŒ Ùˆ"} },
{ id:"u", name:"Ø¦Û‡", label:"u", forms:{final:"Ù€Û‡ØŒ Ù€Ø¦Û‡", isolated:"Ø¦Û‡ØŒ Û‡"} },
{ id:"Ã¶", name:"Ø¦Û†", label:"Ã¶", forms:{final:"Ù€Û†ØŒ Ù€Ø¦Û†", isolated:"Ø¦Û†ØŒ Û†"} },
{ id:"Ã¼", name:"Ø¦Ûˆ", label:"Ã¼", forms:{final:"Ù€ÛˆØŒ Ù€Ø¦Ûˆ", isolated:"Ø¦ÛˆØŒ Ûˆ"} },
{ id:"w", name:"Û‹", label:"w", forms:{final:"Ù€Û‹", isolated:"Û‹"} },
{ id:"yeh", name:"ÙŠ", label:"y", forms:{final:"Ù€ÙŠ", medial:"Ù€ÙŠÙ€", initial:"ÙŠÙ€", isolated:"ÙŠ"} },
{ id:"e2", name:"Ø¦Û", label:"e", forms:{final:"Ù€Û", medial:"Ù€Ø¦ÛÙ€ØŒ Ù€ÛÙ€", initial:"Ø¦ÛÙ€ØŒ ÛÙ€", isolated:"Ø¦ÛØŒ Û"} },
{ id:"i", name:"Ø¦Ù‰", label:"i", forms:{final:"Ù€Ù‰", medial:"Ù€Ø¦Ù‰Ù€ØŒ Ù€Ù‰Ù€", initial:"Ø¦Ù‰Ù€ØŒ Ù‰Ù€", isolated:"Ø¦Ù‰ØŒ Ù‰"} }
];

const FORM_ORDER = ["final","medial","initial","isolated"];

function shuffled(array){ const a = array.slice(); for(let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]];} return a; }
function uid(){ return Math.random().toString(36).slice(2,9); }

function UyghurAlphabetClickMatch(){
  const [count,setCount] = useState(10);
  const [key,setKey] = useState(0);
  const [rtl,setRtl] = useState(true);
  const [selectedTile,setSelectedTile] = useState(null);

  const chosenLetters = useMemo(()=>{
    const subset = shuffled(LETTERS).slice(0,count);
    return subset.map(L=>({...L,rowId:uid()}));
  },[count,key]);

  const tiles = useMemo(()=>{
    let t=[];
    chosenLetters.forEach(L=>{
      FORM_ORDER.forEach(form=>{
        if(L.forms[form]) t.push({id:`${L.id}-${form}-${uid()}`, letterId:L.id, rowId:L.rowId, form, glyph:L.forms[form], base:L.name});
      });
    });
    return shuffled(t);
  },[chosenLetters]);

  const [placements,setPlacements] = useState({});
  useEffect(()=>{ setPlacements({}); setSelectedTile(null); },[key,count]);

  function handleTileClick(tile){ setSelectedTile(tile); }
  function handleSlotClick(slotId,expectForm){
    if(!selectedTile) return;
    setPlacements(prev=>{
      const next = {...prev};
      for(const k of Object.keys(next)) if(next[k]===selectedTile.id) delete next[k];
      next[slotId] = selectedTile.id;
      return next;
    });
    setSelectedTile(null);
  }

  const placedIds = new Set(Object.values(placements));
  const availableTiles = tiles.filter(t=>!placedIds.has(t.id));

  const { correctCount,totalSlots,allCorrect } = useMemo(()=>{
    let correct=0,total=0;
    chosenLetters.forEach(L=>{
      FORM_ORDER.forEach(form=>{
        if(!L.forms[form]) return;
        total++;
        const slotId = `${L.rowId}:${L.id}:${form}`;
        const tileId = placements[slotId];
        if(!tileId) return;
        const tile = tiles.find(t=>t.id===tileId);
        if(tile && tile.letterId===L.id && tile.form===form && tile.rowId===L.rowId) correct++;
      });
    });
    return {correctCount:correct,totalSlots:total,allCorrect:correct===total};
  },[placements,tiles,chosenLetters]);

  function Slot({slotId,expectForm}){
    const tileId = placements[slotId];
    const tile = tiles.find(t=>t.id===tileId);
    const correct = tile && tile.form===expectForm && tile.rowId===slotId.split(':')[0];
    const selected = selectedTile && tileId===selectedTile.id;
    return (
      <div onClick={()=>handleSlotClick(slotId,expectForm)}
        className={"slot border rounded-2xl p-3 h-20 flex items-center justify-center text-3xl shadow-sm transition-all select-none "+
          (tile ? (correct ? "border-emerald-500 ring-1 ring-emerald-400" : "border-rose-400 ring-1 ring-rose-300") : "border-gray-300")+
          (selected ? " selected":"")} dir={rtl?"rtl":"ltr"}>
        {tile ? <span dir={rtl?"rtl":"ltr"}>{tile.glyph}</span> : <span className="text-xs text-gray-400 uppercase">{expectForm}</span>}
      </div>
    );
  }

  return (
    <div className="space-y-6" dir={rtl?"rtl":"ltr"}>
      <header className="flex flex-col md:flex-row md:items-end md:justify-between gap-4">
        <div>
          <h1 className="text-2xl md:text-3xl font-bold">ðŸ§© Uyghur Alphabet Click & Match</h1>
          <p className="text-gray-600">Click a tile, then click the matching slot.</p>
        </div>
        <div className="flex gap-2">
          <button onClick={()=>setKey(k=>k+1)} className="px-4 py-2 rounded-2xl shadow-sm border">New round</button>
          <label className="px-3 py-2 rounded-2xl shadow-sm border inline-flex items-center gap-2">
            <input type="checkbox" checked={rtl} onChange={(e)=>setRtl(e.target.checked)} /> RTL layout
          </label>
          <select className="bg-transparent outline-none" value={count} onChange={(e)=>setCount(Number(e.target.value))}>
            {[2, 4, 6, 8, 10, 12, 16].map(n=><option key={n} value={n}>{n} letters</option>)}
          </select>
        </div>
      </header>

      <div className="flex items-center gap-3">
        <div className="h-2 bg-gray-200 rounded-full w-full overflow-hidden">
          <div className="h-2 bg-emerald-500 transition-all" style={{width:`${(correctCount/totalSlots)*100}%`}}></div>
        </div>
        <div className="text-sm tabular-nums text-gray-600 w-28 text-right">{correctCount}/{totalSlots}</div>
      </div>

      {allCorrect && <div className="p-4 border rounded-2xl bg-emerald-50 border-emerald-200 text-emerald-800">âœ… All correct!</div>}

      <section className="grid grid-cols-1 gap-4">
        {chosenLetters.map(L=>(
          <div key={L.rowId} className="card">
            <div className="flex items-center justify-between mb-3">
              <div className="flex items-center gap-3">
                <div className="text-3xl md:text-4xl" dir={rtl?"rtl":"ltr"}>{L.name}</div>
                <div className="text-xs text-gray-500 uppercase">{L.label}</div>
              </div>
              <div className="text-xs text-gray-400">Match the forms</div>
            </div>
            <div className="grid grid-cols-2 md:grid-cols-4 gap-3">
              {FORM_ORDER.map(form=>L.forms[form]?<Slot key={L.rowId+'-'+form} slotId={`${L.rowId}:${L.id}:${form}`} expectForm={form} />:null)}
            </div>
          </div>
        ))}
      </section>

      <section className="card">
        <div className="grid grid-cols-4 sm:grid-cols-6 md:grid-cols-8 lg:grid-cols-10 gap-3" dir={rtl?"rtl":"ltr"}>
          {availableTiles.map(tile=>(
            <button key={tile.id} onClick={()=>handleTileClick(tile)}
              className="border rounded-2xl p-3 h-20 flex items-center justify-center text-3xl bg-white hover:shadow shadow-sm select-none">
              <span dir={rtl?"rtl":"ltr"}>{tile.glyph}</span>
            </button>
          ))}
        </div>
      </section>
    </div>
  );
}

ReactDOM.createRoot(document.getElementById('root')).render(<UyghurAlphabetClickMatch />);
</script>
</body>
</html>

