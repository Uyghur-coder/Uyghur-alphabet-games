<!doctype html>
<html lang="en" dir="rtl">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Uyghur Alphabet Click & Match</title>

<script src="https://cdn.tailwindcss.com"></script>
<style>
@font-face {
    font-family: 'UyghurFont';
    src: url('fonts/UKIJTuz.ttf') format('truetype');
    font-weight: normal;
    font-style: normal;
}
body { -webkit-font-smoothing:antialiased; -moz-osx-font-smoothing:grayscale; font-family: 'UyghurFont', Arial, sans-serif; }
.direction-rtl { direction: rtl; }
.direction-ltr { direction: ltr; }
.selected { border: 2px solid #3b82f6; }
.letter-glyph { font-size: 2.5rem; text-align: center; word-break: break-word; }
.letter-latin { font-size: 1.4rem; text-align: center; display: block; margin-top: 4px; }
.flash-correct { background-color: #d1fae5 !important; } /* green-100 */
.flash-wrong { background-color: #fee2e2 !important; }   /* red-100 */
</style>
</head>
<body class="bg-gray-50 p-6">

<div id="root" class="max-w-6xl mx-auto"></div>

<script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
<script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
<script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

<script type="text/babel">
const { useState, useEffect } = React;

// Full Uyghur alphabet array
const LETTERS = [
  { id: "a", base: "ئا", latin: "[a]", sound: "sounds/aa.m4a", forms: { final: "ـا", medial: "ـئا", initial: "ئا", isolated: "ا" } },
  { id: "e", base: "ئە", latin: "[e]", sound: "sounds/ae.m4a", forms: { final: "ـە", medial: "ـئە", initial: "ئە", isolated: "ە" } },
  { id: "é", base: "ئې", latin: "[é]", sound: "sounds/ee.m4a", forms: { final: "ـې", medial: "ـې", initial: "ئې", isolated: "ې" } },
  { id: "i", base: "ئى", latin: "[i]", sound: "sounds/i.m4a", forms: { final: "ـى", medial: "ـى", initial: "ئى", isolated: "ى" } },
  { id: "o", base: "ئو", latin: "[o]", sound: "sounds/o.m4a", forms: { final: "ـو", medial: "ـو", initial: "ئو", isolated: "و" } },
  { id: "u", base: "ئۇ", latin: "[u]", sound: "sounds/u.m4a", forms: { final: "ـۇ", medial: "ـۇ", initial: "ئۇ", isolated: "ۇ" } },
  { id: "ö", base: "ئۆ", latin: "[ö]", sound: "sounds/oe.m4a", forms: { final: "ـۆ", medial: "ـۆ", initial: "ئۆ", isolated: "ۆ" } },
  { id: "ü", base: "ئۈ", latin: "[ü]", sound: "sounds/ue.m4a", forms: { final: "ـۈ", medial: "ـۈ", initial: "ئۈ", isolated: "ۈ" } },
  { id: "b", base: "ب", latin: "[b]", sound: "sounds/b.m4a", forms: { final: "ـب", medial: "ـبـ", initial: "بـ", isolated: "ب" } },
  { id: "p", base: "پ", latin: "[p]", sound: "sounds/p.m4a", forms: { final: "ـپ", medial: "ـپـ", initial: "پـ", isolated: "پ" } },
  { id: "t", base: "ت", latin: "[t]", sound: "sounds/t.m4a", forms: { final: "ـت", medial: "ـتـ", initial: "تـ", isolated: "ت" } },
  { id: "j", base: "ج", latin: "[j]", sound: "sounds/j.m4a", forms: { final: "ـج", medial: "ـجـ", initial: "جـ", isolated: "ج" } },
  { id: "ch", base: "چ", latin: "[ch]", sound: "sounds/ch.m4a", forms: { final: "ـچ", medial: "ـچـ", initial: "چـ", isolated: "چ" } },
  { id: "x", base: "خ", latin: "[x]", sound: "sounds/x.m4a", forms: { final: "ـخ", medial: "ـخـ", initial: "خـ", isolated: "خ" } },
  { id: "d", base: "د", latin: "[d]", sound: "sounds/d.m4a", forms: { final: "ـد", medial: null, initial: "د", isolated: "د" } },
  { id: "r", base: "ر", latin: "[r]", sound: "sounds/r.m4a", forms: { final: "ـر", medial: null, initial: "ر", isolated: "ر" } },
  { id: "z", base: "ز", latin: "[z]", sound: "sounds/z.m4a", forms: { final: "ـز", medial: null, initial: "ز", isolated: "ز" } },
  { id: "s", base: "س", latin: "[s]", sound: "sounds/s.m4a", forms: { final: "ـس", medial: "ـسـ", initial: "سـ", isolated: "س" } },
  { id: "sh", base: "ش", latin: "[sh]", sound: "sounds/sh.m4a", forms: { final: "ـش", medial: "ـشـ", initial: "شـ", isolated: "ش" } },
  { id: "gh", base: "غ", latin: "[gh]", sound: "sounds/gh.m4a", forms: { final: "ـغ", medial: "ـغـ", initial: "غـ", isolated: "غ" } },
  { id: "f", base: "ف", latin: "[f]", sound: "sounds/f.m4a", forms: { final: "ـف", medial: "ـفـ", initial: "فـ", isolated: "ف" } },
  { id: "k", base: "ك", latin: "[k]", sound: "sounds/k.m4a", forms: { final: "ـك", medial: "ـكـ", initial: "كـ", isolated: "ك" } },
  { id: "q", base: "ق", latin: "[q]", sound: "sounds/q.m4a", forms: { final: "ـق", medial: "ـقـ", initial: "قـ", isolated: "ق" } },
  { id: "ng", base: "ڭ", latin: "[ng]", sound: "sounds/ng.m4a", forms: { final: "ـڭ", medial: "ـڭـ", initial: "ڭـ", isolated: "ڭ" } },
  { id: "l", base: "ل", latin: "[l]", sound: "sounds/l.m4a", forms: { final: "ـل", medial: "ـلـ", initial: "لـ", isolated: "ل" } },
  { id: "m", base: "م", latin: "[m]", sound: "sounds/m.m4a", forms: { final: "ـم", medial: "ـمـ", initial: "مـ", isolated: "م" } },
  { id: "n", base: "ن", latin: "[n]", sound: "sounds/n.m4a", forms: { final: "ـن", medial: "ـنـ", initial: "نـ", isolated: "ن" } },
  { id: "h", base: "ھ", latin: "[h]", sound: "sounds/h.m4a", forms: { final: "ـھ", medial: "ـھـ", initial: "ھـ", isolated: "ھ" } },
  { id: "o", base: "ۋ", latin: "[w]", sound: "sounds/w.m4a", forms: { final: "ـۋ", medial: "ـۋـ", initial: "ۋـ", isolated: "ۋ" } },
  { id: "y", base: "ي", latin: "[y]", sound: "sounds/y.m4a", forms: { final: "ـي", medial: "ـيـ", initial: "يـ", isolated: "ي" } },
  { id: "é", base: "ئ", latin: "[']", sound: "sounds/apostrophe.m4a", forms: { final: null, medial: null, initial: "ئ", isolated: "ئ" } }
];

const FORM_TYPES = ["final","medial","initial","isolated"];

// Preload all sounds
const soundMap = {};
LETTERS.forEach(letter => {
  if(letter.sound){
    const audio = new Audio(letter.sound);
    audio.preload = "auto";
    soundMap[letter.id] = audio;
  }
});

function UyghurAlphabetGame() {
  const [placements, setPlacements] = useState({});
  const [selectedTile, setSelectedTile] = useState(null);
  const [rtl, setRtl] = useState(true);
  const [tiles, setTiles] = useState([]);

  useEffect(() => { setTiles(generateTiles()); }, []);

  const generateTiles = () => {
    return LETTERS.flatMap(letter => FORM_TYPES.map(form => ({
      id: `${letter.id}-${form}-${Math.random().toString(36).slice(2,6)}`,
      letterId: letter.id,
      form,
      glyph: letter.forms[form],
      latin: letter.latin,
      sound: letter.sound
    })).filter(s => s.glyph)).sort(() => 0.5 - Math.random());
  };

  const handleTileClick = tile => {
    setSelectedTile(tile);
    if(tile.sound && soundMap[tile.letterId]){
      soundMap[tile.letterId].currentTime = 0;
      soundMap[tile.letterId].play();
    } else {
      const utter = new SpeechSynthesisUtterance(tile.glyph);
      utter.lang = "ug-CN";
      speechSynthesis.speak(utter);
    }
  };

  const handleSlotClick = slotId => {
    if(!selectedTile) return;
    const slotCorrect = selectedTile.letterId === slotId.split('-')[0] &&
                        selectedTile.form === slotId.split('-')[1];

    setPlacements(prev => {
      const next = { ...prev };
      Object.keys(next).forEach(k => { if(next[k]===selectedTile.id) delete next[k]; });
      next[slotId] = selectedTile.id;
      return next;
    });

    const el = document.getElementById(slotId);
    if(el){
      el.classList.add(slotCorrect ? 'flash-correct' : 'flash-wrong');
      setTimeout(()=>el.classList.remove(slotCorrect ? 'flash-correct' : 'flash-wrong'),500);
    }

    setSelectedTile(null);
  };

  const placedIds = new Set(Object.values(placements));
  const availableTiles = tiles.filter(t => !placedIds.has(t.id));

  const correctCount = LETTERS.reduce((acc,letter)=>{
    FORM_TYPES.forEach(form=>{
      const slotId = `${letter.id}-${form}`;
      const tileId = placements[slotId];
      const tile = tiles.find(t=>t.id===tileId);
      if(tile && tile.letterId===letter.id && tile.form===form) acc++;
    });
    return acc;
  },0);

  const handleNewRound = () => {
    setPlacements({});
    setTiles(generateTiles());
  };

  return (
    <div className="p-6 max-w-6xl mx-auto">
      <div className="flex justify-between mb-4">
        <button onClick={()=>setRtl(!rtl)} className="px-3 py-1 rounded bg-gray-200">Toggle RTL</button>
        <button onClick={handleNewRound} className="px-3 py-1 rounded bg-blue-500 text-white">New Round / Shuffle</button>
        <div>Correct: {correctCount} / {LETTERS.length*FORM_TYPES.length}</div>
      </div>

      <div className={`grid grid-cols-4 md:grid-cols-6 lg:grid-cols-8 gap-3 mb-6 ${rtl?'direction-rtl':'direction-ltr'}`}>
        {LETTERS.flatMap(letter => FORM_TYPES.map(form => {
          const slotId = `${letter.id}-${form}`;
          const tileId = placements[slotId];
          const tile = tiles.find(t=>t.id===tileId);
          return (
            <div key={slotId} id={slotId} onClick={()=>handleSlotClick(slotId)} className={`h-28 flex flex-col items-center justify-center border-2 border-dashed rounded-xl cursor-pointer ${tile?'border-green-500':'border-gray-300'}`}>
              {tile ? <>
                <span className="letter-glyph">{tile.glyph}</span>
                <span className="letter-latin">{tile.latin}</span>
              </> : <span className="text-gray-400">{form}</span>}
            </div>
          );
        }))}
      </div>

      <div className="grid grid-cols-4 sm:grid-cols-6 md:grid-cols-8 lg:grid-cols-10 gap-3">
        {availableTiles.map(tile => (
          <div key={tile.id} onClick={()=>handleTileClick(tile)} className={`h-28 flex flex-col items-center justify-center border rounded-xl cursor-pointer select-none text-3xl ${selectedTile?.id===tile.id?'border-blue-500 bg-blue-50':'bg-white'}`}>
            <span className="letter-glyph">{tile.glyph}</span>
            <span className="letter-latin">{tile.latin}</span>
          </div>
        ))}
      </div>
    </div>
  );
}

ReactDOM.createRoot(document.getElementById('root')).render(<UyghurAlphabetGame />);
</script>
</body>
</html>
